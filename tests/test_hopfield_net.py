import unittest

import numpy as np

from netomaton import HopfieldNet


class TestHopfieldNet(unittest.TestCase):

    def test_hopfield_net(self):
        # patterns for training
        zero = [
            0, 1, 1, 1, 0,
            1, 0, 0, 0, 1,
            1, 0, 0, 0, 1,
            1, 0, 0, 0, 1,
            1, 0, 0, 0, 1,
            0, 1, 1, 1, 0]
        one = [
            0, 1, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0]
        two = [
            1, 1, 1, 0, 0,
            0, 0, 0, 1, 0,
            0, 0, 0, 1, 0,
            0, 1, 1, 0, 0,
            1, 0, 0, 0, 0,
            1, 1, 1, 1, 1]
        # replace the zeroes with -1 to make these vectors bipolar instead of binary
        one = [-1 if x == 0 else x for x in one]
        two = [-1 if x == 0 else x for x in two]
        zero = [-1 if x == 0 else x for x in zero]
        P = [zero, one, two]

        hopfield_net = HopfieldNet(n=30)
        hopfield_net.train(P)

        expected_weights = [[ 0, -1, -1, -1, 1, -1, 1, -1, 3, -1, -1, 1, -1, 3, -1, -1, 3, 1, 1, -1, 1, 1, -1, 1, -1, 3, 1, -1, 1, 3],
                            [-1, 0, 3, -1, -3, -1, -3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -1, 1, -3, -1, 1, -3, -1, -3, -1, -1, 1, 3, 1, -1],
                            [-1, 3, 0, -1, -3, -1, -3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -1, 1, -3, -1, 1, -3, -1, -3, -1, -1, 1, 3, 1, -1],
                            [-1, -1, -1, 0, 1, 3, 1, -1, -1, 3, 3, 1, -1, -1, 3, 3, -1, -3, 1, 3, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [ 1, -3, -3, 1, 0, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, -1, 3, 1, -1, 3, 1, 3, 1, 1, -1, -3, -1, 1],
                            [-1, -1, -1, 3, 1, 0, 1, -1, -1, 3, 3, 1, -1, -1, 3, 3, -1, -3, 1, 3, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [ 1, -3, -3, 1, 3, 1, 0, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, -1, 3, 1, -1, 3, 1, 3, 1, 1, -1, -3, -1, 1],
                            [-1, -1, -1, -1, 1, -1, 1, 0, -1, -1, -1, 1, 3, -1, -1, -1, -1, 1, 1, -1, -3, 1, 3, 1, -1, -1, -3, -1, -3, -1],
                            [ 3, -1, -1, -1, 1, -1, 1, -1, 0, -1, -1, 1, -1, 3, -1, -1, 3, 1, 1, -1, 1, 1, -1, 1, -1, 3, 1, -1, 1, 3],
                            [-1, -1, -1, 3, 1, 3, 1, -1, -1, 0, 3, 1, -1, -1, 3, 3, -1, -3, 1, 3, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [-1, -1, -1, 3, 1, 3, 1, -1, -1, 3, 0, 1, -1, -1, 3, 3, -1, -3, 1, 3, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [ 1, -3, -3, 1, 3, 1, 3, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, -1, 3, 1, -1, 3, 1, 3, 1, 1, -1, -3, -1, 1],
                            [-1, -1, -1, -1, 1, -1, 1, 3, -1, -1, -1, 1, 0, -1, -1, -1, -1, 1, 1, -1, -3, 1, 3, 1, -1, -1, -3, -1, -3, -1],
                            [ 3, -1, -1, -1, 1, -1, 1, -1, 3, -1, -1, 1, -1, 0, -1, -1, 3, 1, 1, -1, 1, 1, -1, 1, -1, 3, 1, -1, 1, 3],
                            [-1, -1, -1, 3, 1, 3, 1, -1, -1, 3, 3, 1, -1, -1, 0, 3, -1, -3, 1, 3, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [-1, -1, -1, 3, 1, 3, 1, -1, -1, 3, 3, 1, -1, -1, 3, 0, -1, -3, 1, 3, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [ 3, -1, -1, -1, 1, -1, 1, -1, 3, -1, -1, 1, -1, 3, -1, -1, 0, 1, 1, -1, 1, 1, -1, 1, -1, 3, 1, -1, 1, 3],
                            [ 1, 1, 1, -3, -1, -3, -1, 1, 1, -3, -3, -1, 1, 1, -3, -3, 1, 0, -1, -3, -1, -1, 1, -1, -3, 1, -1, 1, -1, 1],
                            [ 1, -3, -3, 1, 3, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, -1, 0, 1, -1, 3, 1, 3, 1, 1, -1, -3, -1, 1],
                            [-1, -1, -1, 3, 1, 3, 1, -1, -1, 3, 3, 1, -1, -1, 3, 3, -1, -3, 1, 0, 1, 1, -1, 1, 3, -1, 1, -1, 1, -1],
                            [ 1, 1, 1, 1, -1, 1, -1, -3, 1, 1, 1, -1, -3, 1, 1, 1, 1, -1, -1, 1, 0, -1, -3, -1, 1, 1, 3, 1, 3, 1],
                            [ 1, -3, -3, 1, 3, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, -1, 3, 1, -1, 0, 1, 3, 1, 1, -1, -3, -1, 1],
                            [-1, -1, -1, -1, 1, -1, 1, 3, -1, -1, -1, 1, 3, -1, -1, -1, -1, 1, 1, -1, -3, 1, 0, 1, -1, -1, -3, -1, -3, -1],
                            [ 1, -3, -3, 1, 3, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, -1, 3, 1, -1, 3, 1, 0, 1, 1, -1, -3, -1, 1],
                            [-1, -1, -1, 3, 1, 3, 1, -1, -1, 3, 3, 1, -1, -1, 3, 3, -1, -3, 1, 3, 1, 1, -1, 1, 0, -1, 1, -1, 1, -1],
                            [ 3, -1, -1, -1, 1, -1, 1, -1, 3, -1, -1, 1, -1, 3, -1, -1, 3, 1, 1, -1, 1, 1, -1, 1, -1, 0, 1, -1, 1, 3],
                            [ 1, 1, 1, 1, -1, 1, -1, -3, 1, 1, 1, -1, -3, 1, 1, 1, 1, -1, -1, 1, 3, -1, -3, -1, 1, 1, 0, 1, 3, 1],
                            [-1, 3, 3, -1, -3, -1, -3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -1, 1, -3, -1, 1, -3, -1, -3, -1, -1, 1, 0, 1, -1],
                            [ 1, 1, 1, 1, -1, 1, -1, -3, 1, 1, 1, -1, -3, 1, 1, 1, 1, -1, -1, 1, 3, -1, -3, -1, 1, 1, 3, 1, 0, 1],
                            [ 3, -1, -1, -1, 1, -1, 1, -1, 3, -1, -1, 1, -1, 3, -1, -1, 3, 1, 1, -1, 1, 1, -1, 1, -1, 3, 1, -1, 1, 0,]]
        np.testing.assert_equal(expected_weights, hopfield_net.adjacency_matrix)
